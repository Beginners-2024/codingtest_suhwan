## 1로 만들기 1463
### 소요시간
30분

### 간단 풀이 방식
- dp는 점화식이 중요함
- 2, 3은 무조건 한번의 연산으로 1을 만들 수 있다 dp[2] = 1, dp[3] = 1
    - 2의 연산 : 2 -> 1 (1번)
    - 3의 연산 : 3 -> 1 (1번)
    - 4의 연산 : 4 -> 3 -> 1 OR 4 -> 2 -> 1 (2번)
    - 5의 연산 : 5 -> 4 -> 3 -> 1 OR 5 -> 4 -> 2 -> 1 (3번 = 4의 연산 횟수 + 1);
    - 5 -> {4 -> 2 -> 1 (4의 연산 횟수)}
    - 6의 연산 : 6 -> 2 -> 1 OR 6 -> 3 -> 1 (2번);
    - 6 -> {3 -> 1 (3의 연산 횟수)}
    - 7의 연산 : 7 -> 6 -> 3 -> 1 OR 7 -> 6 -> 2 -> 1 (3번 = 6의 연산 횟수 + 1)
- 여기서 규칙을 발견할 수 있다
- N 번째가 2나 3으로 나누어 떨어진다면, dp[N/2 OR N/3] + 1 값과 dp[i](1을 뺸 결과) 중 min 값을 선택하면 된다.

### pseudo code
```
for (int i = 2; i <= N; i++) {
    dp[i] = dp[i - 1] + 1;

    if (i % 2 == 0) {
        dp[i] = Math.min(dp[i], dp[i / 2] + 1);
    }
    if (i % 3 == 0) {
        dp[i] = Math.min(dp[i], dp[i / 3] + 1);
    }
}
```

### 메모리 및 시간
- 18228kb
- 148ms

## 1, 2, 3 더하기 9095
### 소요시간
15분

### 간단 풀이 방식
- 1를 1, 2, 3으로 만드는 조합 : 1
    - 1
- 2를 1, 2, 3으로 만드는 조합 : 2
    - 1만 사용
        - 1 + 1
    - 2만 사용
        - 2
- 3을 1, 2, 3으로 만드는 조합 : 4
    - 1만 사용
        - 1 + 1 + 1
    - 1, 2 사용
        - 1 + 2
        - 2 + 1
    - 3만 사용
        - 3
- 4를 1, 2, 3으로 만드는 조합 : 7
    - 1만 사용
        - 1 + 1 + 1 + 1
    - 1, 2 사용
        - 2 + 1 + 1
        - 1 + 2 + 1
        - 1 + 1 + 2
    - 1, 3 사용
        - 1 + 3
        - 3 + 1
    - 2만 사용
        - 2 + 2
- 5를 1, 2, 3으로 만드는 조합 : 13
    - 1만 사용
        - 1 + 1 + 1 + 1 + 1
    - 1, 2 사용
        - 1 + 1 + 1 + 2
        - 1 + 1 + 2 + 1
        - 1 + 2 + 1 + 1
        - 2 + 1 + 1 + 1
        - 1 + 2 + 2
        - 2 + 1 + 2
        - 2 + 1 + 2
    - 1, 3 사용
        - 1 + 1 + 3
        - 1 + 3 + 1
        - 3 + 1 + 1
    - 2, 3 사용
        - 2 + 3
        - 3 + 2

즉, dp[i] = dp[i - 3] + dp[i - 2] + dp[i - 1]

### pseudo code
```
for (int i = 4; i <= 11; i++) {
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
}
```

### 메모리 및 시간
- 14392kb
- 100ms

## 계단 오르기 2579
### 소요시간
30분

### 간단 풀이 방식
- 계단 오르는 방식은 연속적으로 3개의 계단을 오를수 없다는게 포인트!
- 마지막 계단 N에 올수 있는 경우의 수
- dp[n - 1] + stair[n] : 한칸만을 올라온 경우
-  stair[n - 1] + stair[n] + dp[n - 3] : 두칸을 올라온 경우 -> dp[n -3]을 더함으로써, 3칸을 연속적으로 밟고 올라오는 경우를 예외처리 가능

### pseudo code
```
for (int i = 3; i <= N; i++) {
    dp[i] = Math.max(dp[i - 2] + stair[i], dp[i - 3] + stair[i] + stair[i - 1]);
}
```

### 메모리 및 시간
- 14232kb
- 132ms
